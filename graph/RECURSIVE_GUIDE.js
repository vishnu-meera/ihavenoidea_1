// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ§  RECURSIVE ENCODING - BRAIN STICKER GUIDE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/*

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ¯ WHY RECURSION IS BEAUTIFUL FOR TREE ENCODING            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚ "To encode a node, first encode its children"               â”‚
â”‚                                                              â”‚
â”‚ Think of it like:                                           â”‚
â”‚ â€¢ Recursion = Natural way to think about trees             â”‚
â”‚ â€¢ Each node only cares about its children                  â”‚
â”‚ â€¢ Base case: leaves are "()"                               â”‚
â”‚ â€¢ Recursive case: wrap children's codes                    â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ”„ RECURSIVE VS ITERATIVE                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚ ITERATIVE (Bottom-Up):                                      â”‚
â”‚ âŒ More complex: track in-degrees, queues, levels          â”‚
â”‚ âŒ Manual parent tracking                                   â”‚
â”‚ âŒ More code to manage state                                â”‚
â”‚ âœ… Explicit control of processing order                     â”‚
â”‚                                                              â”‚
â”‚ RECURSIVE (Top-Down with Memoization):                      â”‚
â”‚ âœ… Cleaner, more intuitive code                             â”‚
â”‚ âœ… Natural tree traversal                                   â”‚
â”‚ âœ… Automatic call stack management                          â”‚
â”‚ âœ… Easy to understand and debug                             â”‚
â”‚ âœ… Memoization prevents recomputation                       â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸŒ³ THE RECURSIVE PATTERN                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  function encode(node, children, memo) {                    â”‚
â”‚    // BASE CASE 1: Already computed?                        â”‚
â”‚    if (memo[node]) return memo[node]                        â”‚
â”‚                                                              â”‚
â”‚    // BASE CASE 2: Leaf node?                               â”‚
â”‚    if (children[node].length === 0) {                       â”‚
â”‚      memo[node] = "()"                                      â”‚
â”‚      return "()"                                            â”‚
â”‚    }                                                         â”‚
â”‚                                                              â”‚
â”‚    // RECURSIVE CASE: Encode all children first             â”‚
â”‚    const childEncodings = []                                â”‚
â”‚    for (const child of children[node]) {                    â”‚
â”‚      childEncodings.push(encode(child, children, memo))     â”‚
â”‚    }                                                         â”‚
â”‚                                                              â”‚
â”‚    // CRITICAL: Sort for canonical encoding!                â”‚
â”‚    childEncodings.sort()                                    â”‚
â”‚                                                              â”‚
â”‚    // Wrap children in parentheses                          â”‚
â”‚    const result = `(${childEncodings.join('')})`            â”‚
â”‚    memo[node] = result                                      â”‚
â”‚    return result                                            â”‚
â”‚  }                                                           â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ“– VISUAL EXAMPLE: Recursive Call Stack                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  Tree:       1                                              â”‚
â”‚             / \                                             â”‚
â”‚            2   3                                            â”‚
â”‚           /     \                                           â”‚
â”‚          4       5                                          â”‚
â”‚                                                              â”‚
â”‚  encode(1) called:                                          â”‚
â”‚    â”œâ”€ encode(2) called:                                     â”‚
â”‚    â”‚    â”œâ”€ encode(4) called:                                â”‚
â”‚    â”‚    â”‚    â””â”€ Leaf! return "()"                           â”‚
â”‚    â”‚    â””â”€ 2's children: ["()"]                             â”‚
â”‚    â”‚    â””â”€ return "(())"                                    â”‚
â”‚    â”‚                                                         â”‚
â”‚    â”œâ”€ encode(3) called:                                     â”‚
â”‚    â”‚    â”œâ”€ encode(5) called:                                â”‚
â”‚    â”‚    â”‚    â””â”€ Leaf! return "()"                           â”‚
â”‚    â”‚    â””â”€ 3's children: ["()"]                             â”‚
â”‚    â”‚    â””â”€ return "(())"                                    â”‚
â”‚    â”‚                                                         â”‚
â”‚    â””â”€ 1's children: ["(())", "(())"]                        â”‚
â”‚    â””â”€ sorted: ["(())", "(())"]                              â”‚
â”‚    â””â”€ return "((())(()))"                                   â”‚
â”‚                                                              â”‚
â”‚  Final: "((())(()))"                                        â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ§  MEMORY ANCHORS FOR RECURSION                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚ 1. "Leaves First" - Base case returns "()"                  â”‚
â”‚ 2. "Trust the Recursion" - Assume children are encoded     â”‚
â”‚ 3. "Sort Before Wrapping" - Canonical form is critical     â”‚
â”‚ 4. "Wrap in Parentheses" - Parent wraps children           â”‚
â”‚ 5. "Memoize" - Don't recompute, cache results              â”‚
â”‚                                                              â”‚
â”‚ Mantra: "My children's codes â†’ sorted â†’ wrapped"           â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ’¡ WHY SORTING MATTERS (AGAIN!)                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  Tree:       A                                              â”‚
â”‚             / \                                             â”‚
â”‚            B   C                                            â”‚
â”‚           /     \                                           â”‚
â”‚          D       E                                          â”‚
â”‚                                                              â”‚
â”‚  WITHOUT sorting at A:                                      â”‚
â”‚  - If we process B then C: "(())(())"                       â”‚
â”‚  - Could be different if traversal order changes!           â”‚
â”‚                                                              â”‚
â”‚  WITH sorting at A:                                         â”‚
â”‚  - Children codes: ["(())", "(())"]                         â”‚
â”‚  - Sorted: ["(())", "(())"] (already sorted here)           â”‚
â”‚  - ALWAYS: "((())(()))" regardless of traversal!            â”‚
â”‚                                                              â”‚
â”‚  Example where sorting changes things:                      â”‚
â”‚  Tree:       A                                              â”‚
â”‚             /|\                                             â”‚
â”‚            B C D                                            â”‚
â”‚            |   |                                            â”‚
â”‚            E   F                                            â”‚
â”‚                                                              â”‚
â”‚  Children of A: ["(())", "()", "(())"]                      â”‚
â”‚  Without sort: Could be "(())()(())" or "()(())(())" etc.   â”‚
â”‚  With sort: ALWAYS "()(())(())"  âœ…                         â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ¯ STEP-BY-STEP TRACE                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  Tree:       1                                              â”‚
â”‚             /|\                                             â”‚
â”‚            2 3 4                                            â”‚
â”‚           /   \                                             â”‚
â”‚          5     6                                            â”‚
â”‚                                                              â”‚
â”‚  Call: encode(1)                                            â”‚
â”‚  â†“                                                           â”‚
â”‚  1 has children [2, 3, 4]                                   â”‚
â”‚  Need to encode each:                                       â”‚
â”‚                                                              â”‚
â”‚  Call: encode(2)                                            â”‚
â”‚  â†“                                                           â”‚
â”‚  2 has children [5]                                         â”‚
â”‚  Call: encode(5)                                            â”‚
â”‚  â†“                                                           â”‚
â”‚  5 is leaf â†’ return "()"                                    â”‚
â”‚  â†‘                                                           â”‚
â”‚  2's children codes: ["()"]                                 â”‚
â”‚  2's encoding: "(())"                                       â”‚
â”‚  â†‘                                                           â”‚
â”‚                                                              â”‚
â”‚  Call: encode(3)                                            â”‚
â”‚  â†“                                                           â”‚
â”‚  3 has children [6]                                         â”‚
â”‚  Call: encode(6)                                            â”‚
â”‚  â†“                                                           â”‚
â”‚  6 is leaf â†’ return "()"                                    â”‚
â”‚  â†‘                                                           â”‚
â”‚  3's children codes: ["()"]                                 â”‚
â”‚  3's encoding: "(())"                                       â”‚
â”‚  â†‘                                                           â”‚
â”‚                                                              â”‚
â”‚  Call: encode(4)                                            â”‚
â”‚  â†“                                                           â”‚
â”‚  4 is leaf â†’ return "()"                                    â”‚
â”‚  â†‘                                                           â”‚
â”‚                                                              â”‚
â”‚  Back to encode(1):                                         â”‚
â”‚  Children codes: ["(())", "(())", "()"]                     â”‚
â”‚  Sort: ["()", "(())", "(())"]                               â”‚
â”‚  Encoding: "()(())(())"                                     â”‚
â”‚                                                              â”‚
â”‚  DONE! âœ¨                                                   â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸš€ COMPLEXITY ANALYSIS                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚ Time Complexity: O(n log n)                                 â”‚
â”‚ â€¢ Visit each node once: O(n)                                â”‚
â”‚ â€¢ Sort children at each node: O(k log k) where k = children â”‚
â”‚ â€¢ Total sorting: O(n log n) worst case                      â”‚
â”‚                                                              â”‚
â”‚ Space Complexity: O(n)                                      â”‚
â”‚ â€¢ Recursion stack depth: O(h) where h = height             â”‚
â”‚ â€¢ Memoization: O(n) for storing encodings                   â”‚
â”‚ â€¢ Worst case: O(n) when tree is a chain (h = n)            â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ› COMMON MISTAKES IN RECURSIVE APPROACH                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚ âŒ Forgetting to sort children encodings                    â”‚
â”‚    â†’ Different traversal orders give different codes        â”‚
â”‚                                                              â”‚
â”‚ âŒ Not memoizing results                                    â”‚
â”‚    â†’ Recomputing same nodes multiple times (inefficient)    â”‚
â”‚                                                              â”‚
â”‚ âŒ Processing parent before all children                    â”‚
â”‚    â†’ Need children's codes first!                           â”‚
â”‚                                                              â”‚
â”‚ âŒ Not handling empty children array                        â”‚
â”‚    â†’ Leaves need special base case                          â”‚
â”‚                                                              â”‚
â”‚ âœ… CORRECT: Check memo, encode children, sort, wrap         â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ“ PRACTICE: Trace This Tree                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  Tree:       A                                              â”‚
â”‚             / \                                             â”‚
â”‚            B   C                                            â”‚
â”‚                                                              â”‚
â”‚  encode(A):                                                 â”‚
â”‚    encode(B):                                               â”‚
â”‚      B is leaf â†’ "()"                                       â”‚
â”‚    encode(C):                                               â”‚
â”‚      C is leaf â†’ "()"                                       â”‚
â”‚    A's children codes: ["()", "()"]                         â”‚
â”‚    sorted: ["()", "()"]                                     â”‚
â”‚    result: "(()())"                                         â”‚
â”‚                                                              â”‚
â”‚  Answer: "(()())" âœ…                                        â”‚
â”‚                                                              â”‚
â”‚                                                              â”‚
â”‚  Now try:    A                                              â”‚
â”‚             /|\                                             â”‚
â”‚            B C D                                            â”‚
â”‚                                                              â”‚
â”‚  encode(A):                                                 â”‚
â”‚    encode(B): "()"                                          â”‚
â”‚    encode(C): "()"                                          â”‚
â”‚    encode(D): "()"                                          â”‚
â”‚    A's children codes: ["()", "()", "()"]                   â”‚
â”‚    sorted: ["()", "()", "()"]                               â”‚
â”‚    result: "(()()())"                                       â”‚
â”‚                                                              â”‚
â”‚  Answer: "(()()())" âœ…                                      â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ’ THE BEAUTY OF CODE REUSE                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚ Our implementation reuses:                                  â”‚
â”‚                                                              â”‚
â”‚ 1. treeCenter() from centreNodesOfTree.js                  â”‚
â”‚    â†’ Finds the center(s) of the tree                        â”‚
â”‚    â†’ Already tested and working!                            â”‚
â”‚                                                              â”‚
â”‚ 2. rootedTree() from rootedtree.js                         â”‚
â”‚    â†’ Converts undirected â†’ rooted tree                      â”‚
â”‚    â†’ Returns {children, root, parent}                       â”‚
â”‚                                                              â”‚
â”‚ 3. encodeTreeRecursive() - NEW!                            â”‚
â”‚    â†’ Recursive encoding with memoization                    â”‚
â”‚    â†’ Clean and elegant                                      â”‚
â”‚                                                              â”‚
â”‚ Benefits:                                                   â”‚
â”‚ âœ… Don't repeat code (DRY principle)                        â”‚
â”‚ âœ… Easier to maintain                                       â”‚
â”‚ âœ… Each function has single responsibility                  â”‚
â”‚ âœ… Can test components independently                        â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ¯ FINAL MENTAL MODEL                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚ Think of encoding like evaluating a math expression:       â”‚
â”‚                                                              â”‚
â”‚ Expression: (2 + 3) Ã— (4 + 5)                               â”‚
â”‚ To evaluate:                                                â”‚
â”‚   1. Evaluate (2 + 3) = 5                                   â”‚
â”‚   2. Evaluate (4 + 5) = 9                                   â”‚
â”‚   3. Multiply: 5 Ã— 9 = 45                                   â”‚
â”‚                                                              â”‚
â”‚ Tree encoding: encode(A with children [B, C])              â”‚
â”‚ To encode:                                                  â”‚
â”‚   1. Encode B = "()"                                        â”‚
â”‚   2. Encode C = "()"                                        â”‚
â”‚   3. Wrap: "(()())"                                         â”‚
â”‚                                                              â”‚
â”‚ Same pattern! Recursion is natural! ğŸŒŸ                     â”‚
â”‚                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

*/
